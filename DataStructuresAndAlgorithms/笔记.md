# 第一章 内容介绍

## 1.1 数据结构和算法内容介绍

### 1.1.1 经典的算法面试题

- 字符串匹配问题:

  1. 有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好"",和一个字串str2 = "尚硅谷你尚硅你"

  2. 现在要判断str1是否含有str2,如果存在,就返回第一次出现的位置,如果没有,则返回-1

  3. 要求用最快的速度来完成匹配

  4. 你的思路是什么？

     暴力匹配[简单,效率低]

     KMP算法《部分匹配表》

- 汉诺塔游戏

  请完成汉诺塔游戏的代码:

  - 要求
    1. 将A塔的所有圆盘移动到C塔。
    2. 小圆盘上不能放大圆盘
    3. 在三根柱子之间一次只能移动一个圆盘

  ![汉诺塔](img/汉诺塔.png)

- 八皇后问题

  ​	八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克思·北瑟尔与1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。【92】=>分治算法

  ![八皇后问题](img/八皇后问题.png)

- 马踏棋盘算法介绍和游戏演示

  ​	马踏棋盘算法也被称为骑士周游问题

  ​	将马随机放在国际象棋的8×8棋盘Board【0~7】【0~7】的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格，会使用到图的深度优化遍历算法(DFS)+贪心算法优化

  ​	![马踏棋盘](img/马踏棋盘.png)

### 1.1.2 数据结构和算法的重要性

1. 算法是程序的灵魂，优秀的程序可以在海量的数据计算时，依然保持高速计算
2. 一般来讲程序会使用内存计算框架(比如Spark)和缓存技术(比如redis等)来优化程序，再深入的思考一下，这些计算框架和缓存技术，它的核心功能是哪个部分呢？
3. 在Unix下开发服务器程序，功能要支持上千万人同时在线，在上线前，做内测，一切OK，上线后，服务器瞬间爆炸，公司的CTO对代码进行优化，再次上线，坚如磐石。程序的灵魂为算法
4. 目前程序员的门槛越来越高，很多一线IT公司(大厂)，都会有数据结构和算法面试题
5. 如果不想永远都是代码工人，那就花时间来研究下数据结构和算法

### 1.1.3 本套数据结构和算法内容介绍

### 1.1.4 课程亮点和授课方式

1. 课程深入，非蜻蜓点水
2. 课程成体系，非星星点灯
3. 高效而愉快的学习，数据结构和算法很有用，很好玩
4. 数据结构和算法很重要，但是相对困难
5. 采用 应用场景->数据结构或算法->剖析原理->分析实现步骤->代码实现的步骤讲解
6. 达到能在工作中运用解决实际问题和优化程序的目的

# 第二章 数据结构和算法概述

## 2.1.1 数据结构和算法的关系

1. 数据结构是一门**研究组织数据方式**的学科,有了编程语言也就有了数据结构,学好数据结构可以编写出更加漂亮,更加有效率的代码。
2. 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去解决。
3. 程序 = 数据结构 + 算法
4. 数据结构是算法的基础，换言之，想要学好算法，需要把数据结构学到位

## 2.2 看几个实际编程中遇到的问题

### 2.2.1 问题一: 字符串替换问题

java代码：

```java
public static void main(String[] args){
    String str = "Java,Java,hello,world!";
    String newStr = str.replaceAll();// 算法
    System.out.println("newStr=" + newStr);
}
```

问：试写出用**单链表**表示的字符串类及字符串结点类的定义，并依次实现它的构造函数、以及计算串长度、串赋值、判断两串相等、求字串、两串连接、求字串在串中位置等7个成员函数。

### 2.2.2 一个五子棋程序

![五子棋](img/五子棋.png)

​		如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能

1. 棋盘 二维数组=>稀疏数组=>写入文件【存档功能】
2. 读取文件=》稀疏数组=》二维数组=》棋盘【接上局】

### 2.2.3 约瑟夫问题(丢手帕问题)

1. Josephu问题为：设编号为1，2，...n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
2. 提示：用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个结点的单循环链表（单向环形链表），然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。
3. 小结：完成约瑟夫问题，需要使用到单向环形链表这个数据结构

### 2.2.4 其它常见算法问题

![其它常见算法问题](img/其它常见算法问题.png)

1. 修路问题=>最小生成树(加权值)【数据结构】+ 普利姆算法
2. 最短路径问题=>图 + 弗洛伊德算法
3. 汉诺塔=>分支算法
4. 八皇后问题=>回朔法 

## 2.3 线性结构和非线性结构

数据结构包括：线性结构和非线性结构。

### 2.3.1 线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系
2. 线性结构由两种不同的存储结构，即**顺序存储结构(数组)**和**链式存储结构(链表)**。顺序存储的线性表称为顺序表，顺序表中的**存储元素是连续**的
3. 链式存储的线性表称为链表，链表中的存储元素**不一定是连续的**，元素节点中存放数据元素以及相邻元素的地址信息
4. 线性结构常见的有：**数组、队列、链表和栈(面试题)**

### 2.3.2 非线性结构

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

# 第三章 稀疏数组和队列

## 3.1 稀疏sparsearray数组

### 3.1.1 先看一个实际的需求

- 编写的五子棋程序中，有存盘退出和续上盘的功能

![稀疏原始数组](img/稀疏原始数组.png)

- 问题
  - 因为该二维数组的很多值是默认值0，因此记录了很多没有意义的数据=>稀疏数组

### 3.1.2 基本介绍

当一个数组中大部分元素为0，或者同一个值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法是：

- 记录数组**一共有几行几列，有多少个不同**的值
- 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而**缩小程序**的规模

稀疏数组举例说明：

![稀疏数组举例说明](img/稀疏数组举例说明.png)



### 3.1.3 应用实例

1. 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
2. 把稀疏数组存盘，并且可以从新恢复原来的二维数组
3. 整体思路分析

![稀疏数组整体思路分析](img/稀疏数组整体思路分析.png)

代码实现:

```java
public class SpareseArray {

	public static void main(String[] args) {
		// 创建一个原始的二维数组 11 * 11
		// 0：表示没有棋子，1表示黑子 2表示蓝子
		int chessArr1[][] = new int[11][11];
		chessArr1[1][2] = 1;
		chessArr1[2][3] = 2;
		chessArr1[4][5] = 2;
		// 输出原始的二维数组
		System.out.println("原始的二维数组~~");
		for (int[] row : chessArr1) {
			for (int data : row) {
				System.out.printf("%d ", data);
			}
			System.out.println();
		}

		// 将二维数组转稀疏数组的思想
		// 1. 先遍历二维数组 得到非0数据的个数
		int sum = 0;
		for (int i = 0; i < 11; i++) {
			for (int j = 0; j < 11; j++) {
				if (chessArr1[i][j] != 0) {
					sum++;
				}
			}
		}

		// 2. 创建对应的稀疏数组
		int sparseArr[][] = new int[sum + 1][3];
		// 给稀疏数组赋值
		sparseArr[0][0] = 11;
		sparseArr[0][1] = 11;
		sparseArr[0][2] = sum;

		// 遍历二维数组，将非0的值存放到sparseArr中
		int count = 0; // 用于记录是第几个非0数据
		for (int i = 0; i < 11; i++) {
			for (int j = 0; j < 11; j++) {
				if (chessArr1[i][j] != 0) {
					count++;
					sparseArr[count][0] = i;
					sparseArr[count][1] = j;
					sparseArr[count][2] = chessArr1[i][j];
				}
			}
		}
		// 输出稀疏数组的形式
		System.out.println();
		System.out.println("得到的稀疏数组为~~~~");
		for (int i = 0; i < sparseArr.length; i++) {
			System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
		}

		// 将稀疏数组恢复成原始的二维数组
		/**
		 * 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 
		 * 2.在读取稀疏数组后几行数组，并赋给原始的二维数组即可
		 */
		// 1.先读取稀疏数组的第一行，根据第一个的数据，创建原始的二维数组
		int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
		
		// 2.在读取稀疏数组后几行的数组，并赋给原始的二维数组即可
		for (int i = 1; i < sparseArr.length; i++) {
			chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
		}
		
		// 输出恢复后的二维数组
		System.out.println();
		System.out.println("恢复后的二维数组");
		
		for (int[] row : chessArr2) {
			for (int data : row) {
				System.out.printf("%d ", data);
			}
			System.out.println();
		}
	}

}
```

### 3.1.4 巩固练习

- 要求：
  - 在前面的基础上，将稀疏数组保存到磁盘上，比如map.data
  - 恢复原来的数组时，读取map.data进行恢复