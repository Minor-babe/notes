# 第一章 内容介绍

## 1.1 数据结构和算法内容介绍

### 1.1.1 经典的算法面试题

- 字符串匹配问题:

  1. 有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好"",和一个字串str2 = "尚硅谷你尚硅你"

  2. 现在要判断str1是否含有str2,如果存在,就返回第一次出现的位置,如果没有,则返回-1

  3. 要求用最快的速度来完成匹配

  4. 你的思路是什么？

     暴力匹配[简单,效率低]

     KMP算法《部分匹配表》

- 汉诺塔游戏

  请完成汉诺塔游戏的代码:

  - 要求
    1. 将A塔的所有圆盘移动到C塔。
    2. 小圆盘上不能放大圆盘
    3. 在三根柱子之间一次只能移动一个圆盘

  ![汉诺塔](img/汉诺塔.png)

- 八皇后问题

  ​	八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克思·北瑟尔与1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。【92】=>分治算法

  ![八皇后问题](img/八皇后问题.png)

- 马踏棋盘算法介绍和游戏演示

  ​	马踏棋盘算法也被称为骑士周游问题

  ​	将马随机放在国际象棋的8×8棋盘Board【0~7】【0~7】的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格，会使用到图的深度优化遍历算法(DFS)+贪心算法优化

  ​	![马踏棋盘](img/马踏棋盘.png)

### 1.1.2 数据结构和算法的重要性

1. 算法是程序的灵魂，优秀的程序可以在海量的数据计算时，依然保持高速计算
2. 一般来讲程序会使用内存计算框架(比如Spark)和缓存技术(比如redis等)来优化程序，再深入的思考一下，这些计算框架和缓存技术，它的核心功能是哪个部分呢？
3. 在Unix下开发服务器程序，功能要支持上千万人同时在线，在上线前，做内测，一切OK，上线后，服务器瞬间爆炸，公司的CTO对代码进行优化，再次上线，坚如磐石。程序的灵魂为算法
4. 目前程序员的门槛越来越高，很多一线IT公司(大厂)，都会有数据结构和算法面试题
5. 如果不想永远都是代码工人，那就花时间来研究下数据结构和算法

### 1.1.3 本套数据结构和算法内容介绍

### 1.1.4 课程亮点和授课方式

1. 课程深入，非蜻蜓点水
2. 课程成体系，非星星点灯
3. 高效而愉快的学习，数据结构和算法很有用，很好玩
4. 数据结构和算法很重要，但是相对困难
5. 采用 应用场景->数据结构或算法->剖析原理->分析实现步骤->代码实现的步骤讲解
6. 达到能在工作中运用解决实际问题和优化程序的目的

# 第二章 数据结构和算法概述

## 2.1.1 数据结构和算法的关系

1. 数据结构是一门**研究组织数据方式**的学科,有了编程语言也就有了数据结构,学好数据结构可以编写出更加漂亮,更加有效率的代码。
2. 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去解决。
3. 程序 = 数据结构 + 算法
4. 数据结构是算法的基础，换言之，想要学好算法，需要把数据结构学到位

## 2.2 看几个实际编程中遇到的问题

### 2.2.1 问题一: 字符串替换问题

java代码：

```java
public static void main(String[] args){
    String str = "Java,Java,hello,world!";
    String newStr = str.replaceAll();// 算法
    System.out.println("newStr=" + newStr);
}
```

问：试写出用**单链表**表示的字符串类及字符串结点类的定义，并依次实现它的构造函数、以及计算串长度、串赋值、判断两串相等、求字串、两串连接、求字串在串中位置等7个成员函数。

### 2.2.2 一个五子棋程序

![五子棋](img/五子棋.png)

​		如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能

1. 棋盘 二维数组=>稀疏数组=>写入文件【存档功能】
2. 读取文件=》稀疏数组=》二维数组=》棋盘【接上局】

### 2.2.3 约瑟夫问题(丢手帕问题)

1. Josephu问题为：设编号为1，2，...n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
2. 提示：用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个结点的单循环链表（单向环形链表），然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。
3. 小结：完成约瑟夫问题，需要使用到单向环形链表这个数据结构

### 2.2.4 其它常见算法问题

![其它常见算法问题](img/其它常见算法问题.png)

1. 修路问题=>最小生成树(加权值)【数据结构】+ 普利姆算法
2. 最短路径问题=>图 + 弗洛伊德算法
3. 汉诺塔=>分支算法
4. 八皇后问题=>回朔法 

## 2.3 线性结构和非线性结构

数据结构包括：线性结构和非线性结构。

### 2.3.1 线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系
2. 线性结构由两种不同的存储结构，即**顺序存储结构(数组)**和**链式存储结构(链表)**。顺序存储的线性表称为顺序表，顺序表中的**存储元素是连续**的
3. 链式存储的线性表称为链表，链表中的存储元素**不一定是连续的**，元素节点中存放数据元素以及相邻元素的地址信息
4. 线性结构常见的有：**数组、队列、链表和栈(面试题)**

### 2.3.2 非线性结构

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

# 第三章 稀疏数组和队列

## 3.1 稀疏sparsearray数组

### 3.1.1 先看一个实际的需求

- 编写的五子棋程序中，有存盘退出和续上盘的功能

![稀疏原始数组](img/稀疏原始数组.png)

- 问题
  - 因为该二维数组的很多值是默认值0，因此记录了很多没有意义的数据=>稀疏数组

### 3.1.2 基本介绍

当一个数组中大部分元素为0，或者同一个值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法是：

- 记录数组**一共有几行几列，有多少个不同**的值
- 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而**缩小程序**的规模

稀疏数组举例说明：

![稀疏数组举例说明](img/稀疏数组举例说明.png)



### 3.1.3 应用实例

1. 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
2. 把稀疏数组存盘，并且可以从新恢复原来的二维数组
3. 整体思路分析

![稀疏数组整体思路分析](img/稀疏数组整体思路分析.png)

代码实现:

```java
public class SpareseArray {

	public static void main(String[] args) {
		// 创建一个原始的二维数组 11 * 11
		// 0：表示没有棋子，1表示黑子 2表示蓝子
		int chessArr1[][] = new int[11][11];
		chessArr1[1][2] = 1;
		chessArr1[2][3] = 2;
		chessArr1[4][5] = 2;
		// 输出原始的二维数组
		System.out.println("原始的二维数组~~");
		for (int[] row : chessArr1) {
			for (int data : row) {
				System.out.printf("%d ", data);
			}
			System.out.println();
		}

		// 将二维数组转稀疏数组的思想
		// 1. 先遍历二维数组 得到非0数据的个数
		int sum = 0;
		for (int i = 0; i < 11; i++) {
			for (int j = 0; j < 11; j++) {
				if (chessArr1[i][j] != 0) {
					sum++;
				}
			}
		}

		// 2. 创建对应的稀疏数组
		int sparseArr[][] = new int[sum + 1][3];
		// 给稀疏数组赋值
		sparseArr[0][0] = 11;
		sparseArr[0][1] = 11;
		sparseArr[0][2] = sum;

		// 遍历二维数组，将非0的值存放到sparseArr中
		int count = 0; // 用于记录是第几个非0数据
		for (int i = 0; i < 11; i++) {
			for (int j = 0; j < 11; j++) {
				if (chessArr1[i][j] != 0) {
					count++;
					sparseArr[count][0] = i;
					sparseArr[count][1] = j;
					sparseArr[count][2] = chessArr1[i][j];
				}
			}
		}
		// 输出稀疏数组的形式
		System.out.println();
		System.out.println("得到的稀疏数组为~~~~");
		for (int i = 0; i < sparseArr.length; i++) {
			System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
		}

		// 将稀疏数组恢复成原始的二维数组
		/**
		 * 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 
		 * 2.在读取稀疏数组后几行数组，并赋给原始的二维数组即可
		 */
		// 1.先读取稀疏数组的第一行，根据第一个的数据，创建原始的二维数组
		int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
		
		// 2.在读取稀疏数组后几行的数组，并赋给原始的二维数组即可
		for (int i = 1; i < sparseArr.length; i++) {
			chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
		}
		
		// 输出恢复后的二维数组
		System.out.println();
		System.out.println("恢复后的二维数组");
		
		for (int[] row : chessArr2) {
			for (int data : row) {
				System.out.printf("%d ", data);
			}
			System.out.println();
		}
	}

}
```

### 3.1.4 巩固练习

- 要求：
  - 在前面的基础上，将稀疏数组保存到磁盘上，比如map.data
  - 恢复原来的数组时，读取map.data进行恢复

## 3.2 队列

### 3.2.1 队列的一个使用场景

银行排队的案例：

![银行叫号](img/银行叫号.png)

### 3.2.2 队列介绍

1. 队列是一个有序列表，可以用数组或是链表来实现。

2. 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出

3. 示意图：（使用数组模拟队列示意图）

   ![队列示意图](img/队列示意图.png)

### 3.2.3 数据模拟队列思路

- 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量

- 因为队列的输出、输入分别从前后端来处理，因此需要两个变量front及rear分别纪录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变，如图所示：

  ![队列示意图](img/队列示意图.png)

- 当我们将数据存入队列时称为“addQueue”,addQueue的处理需要有两个步骤：思路分析

  - 将尾指针往后移：rear+1，当front==rear【空】
  - 若尾指针rear小于队列的最大小标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1【队列满】

- 代码实现:

  ```java
  import java.util.Scanner;
  
  public class ArrayQueueDemo {
      public static void main(String[] args) {
          ArrayQueue arrayQueue = new ArrayQueue(3);
          // 创建一个队列
          char key = ' ';
          Scanner scanner = new Scanner(System.in);
          boolean loop = true;
          while (loop) {
              System.out.println("s(show):显示队列");
              System.out.println("e(exit):退出程序");
              System.out.println("a(add):添加数据");
              System.out.println("g(get):获取数据");
              System.out.println("h(head):查看数据");
              key = scanner.next().charAt(0);
              switch (key) {
                  case 's':
                      arrayQueue.showQueue();
                      break;
                  case 'a':
                      System.out.println("输入一个数");
                      int value = scanner.nextInt();
                      arrayQueue.addQueue(value);
                      break;
                  case 'g':
                      try {
                          int res = arrayQueue.getQueue();
                          System.out.printf("取出的数据是%d\n", res);
                      } catch (Exception e) {
                          System.out.println(e.getMessage());
                      }
                      break;
                  case 'h':
                      try {
                          int res = arrayQueue.headQueue();
                          System.out.printf("队列头的数据是%d\n", res);
                      } catch (Exception e) {
                          System.out.println(e.getMessage());
                      }
                      break;
                  case 'e':
                      scanner.close();
                      loop = false;
                      break;
              }
          }
          System.out.println("程序退出");
      }
  }
  
  class ArrayQueue {
      private int maxSize; // 表示数组的最大容量
      private int front; // 队列头
      private int rear; // 队列尾
      private int[] arr; // 该数据用于存放数据，模拟队列
  
      // 创建队列的构造器
      public ArrayQueue(int maxSize) {
          this.maxSize = maxSize;
          arr = new int[maxSize];
          front = -1; //指向队列的头部，分析出front是指向队列头的前一个
          rear = -1; // 指向队列的尾部，指向队列尾的数据(即队列最后一个数据)
  
      }
  
      // 判断队列是否满
      public boolean isFull() {
          return rear == maxSize-1;
      }
  
      // 判断队列是否为空
      public boolean isEmpty() {
          return front == rear;
      }
  
      // 添加数据到队列
      public void addQueue(int n) {
          // 判断队列是否满
          if (isFull()) {
              System.out.println("队列满，不能加入数据~");
              return;
          }
          rear++;// 让rear 后移
          arr[rear] = n;
      }
  
      // 获取队列的数据，出队列
      public int getQueue() {
          // 判断队列是否为空
          if (isEmpty()) throw new RuntimeException("队列为空，不能取数据");
          front++;
          return arr[front];
      }
  
      // 显示队列的所有数据
      public void showQueue() {
          // 遍历
          if (isEmpty()) {
              System.out.println("队列为空，没有数据！！");
              return;
          }
          for (int i = 0; i < arr.length; i++) {
              System.out.printf("arr[%d]=%d\n", i, arr[i]);
          }
      }
  
      // 显示队列的头数据，注意不是取出数据
      public int headQueue() {
          if (isEmpty())
              throw new RuntimeException("队列为空，没有数据");
          return arr[front + 1];
      }
  }
  
  ```

- 问题分析并优化

  - 目前数组使用一次就不能用，没有达成复用效果
  - 将这个数组使用算法，改进成一个环形的数组

### 3.2.4 数组模拟环形队列

​	对前面的数组模拟队列的优化，充分利用数组，因此将数组看成环形的。（通过取模的方式来实现）

- 分析说明

  - 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候要注意(rear+1)%maxSize == front [满]

  - rear== front [空]

  - 分析示意图：

    ![环形队列思路分析图](img/环形队列思路分析图.png)
    
  - 代码实现
  
    ```java
    import java.util.Scanner;
    
    public class CircelArrayDemo {
    
        public static void main(String[] args) {
            CircleArray arrayQueue = new CircleArray(4);
            // 创建一个队列
            char key = ' ';
            Scanner scanner = new Scanner(System.in);
            boolean loop = true;
            while (loop) {
                System.out.println("s(show):显示队列");
                System.out.println("e(exit):退出程序");
                System.out.println("a(add):添加数据");
                System.out.println("g(get):获取数据");
                System.out.println("h(head):查看数据");
                key = scanner.next().charAt(0);
                switch (key) {
                    case 's':
                        arrayQueue.showQueue();
                        break;
                    case 'a':
                        System.out.println("输入一个数");
                        int value = scanner.nextInt();
                        arrayQueue.addQueue(value);
                        break;
                    case 'g':
                        try {
                            int res = arrayQueue.getQueue();
                            System.out.printf("取出的数据是%d\n", res);
                        } catch (Exception e) {
                            System.out.println(e.getMessage());
                        }
                        break;
                    case 'h':
                        try {
                            int res = arrayQueue.headQueue();
                            System.out.printf("队列头的数据是%d\n", res);
                        } catch (Exception e) {
                            System.out.println(e.getMessage());
                        }
                        break;
                    case 'e':
                        scanner.close();
                        loop = false;
                        break;
                }
            }
            System.out.println("程序退出");
        }
    }
    
    class CircleArray {
        private int maxSize; // 表示数组的最大容量
        // front 变量的含义做一个调整：front就只想队列的第一个元素，也就是说arr[front]
        // front 的初始值为0
        private int front; // 队列头
        // rear 变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置。希望空出一个位置
        // rear 的初始值=0
        private int rear; // 队列尾
        private int[] arr; //该数组用于存放数据，模拟队列
    
        public CircleArray(int maxSize) {
            this.maxSize = maxSize;
            arr = new int[maxSize];
        }
    
        // 判断是否满
        public boolean isFull() {
            return (rear + 1) % maxSize == front;
        }
    
        // 判断队列是否为空
        public boolean isEmpty() {
            return rear == front;
        }
    
        // 添加数据到队列
        public void addQueue(int n) {
            // 判断队列是否满
            if (isFull()) {
                System.out.println("队列满");
                return;
            }
            arr[rear] = n;
            rear = (rear + 1) % maxSize;
        }
    
        // 获取队列的数据，出队列
        public int getQueue() {
            if (isEmpty()) throw new RuntimeException("队列空，不能取数据");
            int value = arr[front];
            front = (front + 1) % maxSize;
            return value;
        }
    
        // 显示队列
        public void showQueue() {
            // 遍历
            if (isEmpty()) {
                System.out.println("队列空");
                return;
            }
            for (int i = front; i < front + size(); i++) {
                System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
            }
        }
    
        // 求出当前队列有效数据的个数
        public int size() {
            return (rear + maxSize - front) % maxSize;
        }
    
        // 显示队列的头数据，注意不是取出数据
        public int headQueue() {
            if (isEmpty())
                throw new RuntimeException("队列为空，没有数据");
            return arr[front];
        }
    }
    
    ```
  
    

## 4.1 链表(LinkedList)介绍

链表是有序的列表，但是它再内存中的存储如下

![单链表示意图](img/单链表示意图.png)

小结：

1. 链表是以节点的方式来存储，是**链式储存**

2. 每个节点包含data域，next域：指向下一个节点

3. 如图：**链表的各个节点不一定是连续存储**

4. 链表分**带头节点的链表**和**没有头节点的链表**，根据实际需求来确定

   1. 单链表逻辑结构示意图

      ![单链表逻辑结构示意图](img/单链表逻辑结构示意图.png)

## 4.2 单链表的应用实例

使用带head头的单向链表实现水浒英雄排行榜管理完成对英雄人物的增删改查操作。

- 第一种方法在添加英雄时，直接添加到链表的尾部
  - 思路分析示意图

    ![添加单向链表思路示意图](img/添加单向链表思路示意图.png)

  - 代码实现

    ```java
     /**
         * 添加节点到单向链表
         * 1.找到当前链表的最后节点
         * 2.将最后这个节点的next指向新的节点
         *
         * @param heroNode
         */
        void add(HeroNode heroNode) {
            // 因为head节点不能动，因此我们需要一个辅助遍历
            HeroNode temp = head;
            // 遍历链表，找到最后
            while (temp.next != null) {
                // 如果没有找到最后，将temp后移
                temp = temp.next;
            }
            // 当退出while循环时,temp就指向了链表的最后
            temp.next = heroNode;
        }
    ```

    

- 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排序，则添加失败，并给出提示)
  - 思路分析图

    ![添加单向链表思路示意图2](img/添加单向链表思路示意图2.png)

  - 代码实现

    ```java
     /**
         * 根据排名将英雄插入到指定位置
         *
         * @param heroNode
         */
        public void addByOrder(HeroNode heroNode) {
            HeroNode temp = head;
            boolean flag = false;
            // 为null表示找到了最后
            while (temp.next != null) {
                if (temp.next.no > heroNode.no) {
                    // 位置找到，就在temp后面插入
                    break;
                } else if (temp.next.no == heroNode.no) {
                    // 说明编号存在
                    flag = true;
                    break;
                }
                temp = temp.next;
            }
            if (flag) {
                System.out.println("已存在");
            } else {
                heroNode.next = temp.next;
                temp.next = heroNode;
            }
        }
    ```

    

    

- 修改节点功能

  - 思路

    - 找到该节点，通过遍历
    - temp.name = newHeroNode.name
    - temp.nickName = newHeroNode.nickName 

  - 代码实现

    ```java
     /**
         * 更新
         * @param newHeroNode
         */
        void update (HeroNode newHeroNode) {
            if (newHeroNode == null) {
                System.out.println("链表为空");
                return;
            }
            HeroNode temp = head.next;
            boolean flag = false;
            while(temp != null) {
                if (temp.no == newHeroNode.no) {
                    temp.name = newHeroNode.name;
                    temp.nickName = newHeroNode.nickName;
                    flag = true;
                    break;
                }
                temp = temp.next;
            }
            if (!flag){
                System.out.println("没有找到");
            }
        }
    ```

    

- 删除节点功能

  - 思路分析代码示意图

    ![删除单向链表思路示意图](img/删除单向链表思路示意图.png)

  - 代码实现

    ```java
     void del (int no ) {
            HeroNode temp = head;
            boolean flag = false;
            while(temp.next != null ){
                if (temp.next.no == no) {
                    flag = true;
                    break;
                }
                temp= temp.next;
            }
            if (flag) {
                temp.next = temp.next.next;
            } else {
                System.out.println("无法删除");
            }
        }
    ```

- 完整代码

  ```java
  package linklist;
  
  class SingleLinkedListDemo {
      public static void main(String[] args) {
          HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
          HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
          HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
          HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
          // 创建链表
          SingleLinkedList singleLinkedList = new SingleLinkedList();
          // 添加
          singleLinkedList.addByOrder(hero1);
          singleLinkedList.addByOrder(hero4);
          singleLinkedList.addByOrder(hero2);
          singleLinkedList.addByOrder(hero3);
  
          // 测试修改节点的代码
          HeroNode hero5 = new HeroNode(4, "林2冲", "豹2子头");
          singleLinkedList.update(hero5);
          // 遍历
          singleLinkedList.del(4);
          singleLinkedList.del(3);
          singleLinkedList.del(2);
          singleLinkedList.del(1);
          singleLinkedList.list();
      }
  }
  
  class SingleLinkedList {
      // 初始化一个头节点，不存放具体的数据
      private HeroNode head = new HeroNode(0, "", "");
  
  
      void del (int no ) {
          HeroNode temp = head;
          boolean flag = false;
          while(temp.next != null ){
              if (temp.next.no == no) {
                  flag = true;
                  break;
              }
              temp= temp.next;
          }
          if (flag) {
              temp.next = temp.next.next;
          } else {
              System.out.println("无法删除");
          }
      }
  
      /**
       * 更新
       * @param newHeroNode
       */
      void update (HeroNode newHeroNode) {
          if (newHeroNode == null) {
              System.out.println("链表为空");
              return;
          }
          HeroNode temp = head.next;
          boolean flag = false;
          while(temp != null) {
              if (temp.no == newHeroNode.no) {
                  temp.name = newHeroNode.name;
                  temp.nickName = newHeroNode.nickName;
                  flag = true;
                  break;
              }
              temp = temp.next;
          }
          if (!flag){
              System.out.println("没有找到");
          }
      }
      /**
       * 添加节点到单向链表
       * 1.找到当前链表的最后节点
       * 2.将最后这个节点的next指向新的节点
       *
       * @param heroNode
       */
      void add(HeroNode heroNode) {
          // 因为head节点不能动，因此我们需要一个辅助遍历
          HeroNode temp = head;
          // 遍历链表，找到最后
          while (temp.next != null) {
              // 如果没有找到最后，将temp后移
              temp = temp.next;
          }
          // 当退出while循环时,temp就指向了链表的最后
          temp.next = heroNode;
      }
  
      /**
       * 根据排名将英雄插入到指定位置
       *
       * @param heroNode
       */
      public void addByOrder(HeroNode heroNode) {
          HeroNode temp = head;
          boolean flag = false;
          // 为null表示找到了最后
          while (temp.next != null) {
              if (temp.next.no > heroNode.no) {
                  // 位置找到，就在temp后面插入
                  break;
              } else if (temp.next.no == heroNode.no) {
                  // 说明编号存在
                  flag = true;
                  break;
              }
              temp = temp.next;
          }
          if (flag) {
              System.out.println("已存在");
          } else {
              heroNode.next = temp.next;
              temp.next = heroNode;
          }
      }
  
      /**
       * 遍历
       */
      void list() {
          // 判断链表是否为空
          if (head.next == null) {
              System.out.println("链表为空");
              return;
          }
          // 因为头节点不能动，因此我们需要一个辅助变量来遍历
          HeroNode temp = head.next;
          while (temp != null) {
  
              // 输出节点信息
              System.out.println(temp);
              temp = temp.next;
          }
      }
  }
  
  class HeroNode {
      int no;
      String name;
      String nickName;
      HeroNode next;
  
      public HeroNode(int no, String name, String nickName) {
          this.no = no;
          this.name = name;
          this.nickName = nickName;
      }
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "no=" + no +
                  ", name='" + name + '\'' +
                  ", nickName='" + nickName + '\'' +
                  '}';
      }
  }
  ```


## 4.3 单链表的面试题(新浪、百度、腾讯)

1. 求单链表当中有效节点的个数

   ```java
      /**
        * 获取到单链表的节点的个数(如果是带头的节点的链表，需要不统计头节点)
        *
        * @param head
        * @return
        */
       public static int getLength(HeroNode head) {
           int length = 0;
           if (head.next == null) {
               return length;
           }
           // 定义一个辅助变量
           HeroNode cur = head.next;
           while (cur != null) {
               length++;
               cur = cur.next;
           }
           return length;
       }
   ```

2. 查找单链表中的倒数第K个节点【新浪】

   ```java
     /**
        * 查找单链表中的倒数第K个节点【新浪面试题】
        * 思路：
        * 1.编写一个方法，接收head节点，同时接收一个index
        * 2.index表示倒数第index个节点
        * 3.先把链表从头到尾遍历，得到链表的总长度length
        * 4.得到length之后，我们从链表的第一个开始遍历(length-index)个，就可以得到
        * 5.如果找到了，则返回该节点，否则返回null
        *
        * @param head
        * @param index
        * @return
        */
       public static HeroNode findLastIndex(HeroNode head, int index) {
           if (head.next == null) {
               return null;
           }
           int length = getLength(head);
           if (index <= 0 || index > length) {
               return null;
           }
           HeroNode temp = head.next;
           for (int i = 0; i < (length - index); i++) {
               temp = temp.next;
           }
           return temp;
       }
   ```

3. 单链表的反转【腾讯】

   思路分析图：

   ![单链表的反转思路图](img/单链表的反转思路图.png)

   ![单链表的反转思路图2](img/单链表的反转思路图2.png)

   ```java
     /**
        * 将单链表反转【腾讯】
        *
        *
        * @param head
        */
       public static void reversetList(HeroNode head) {
           // 如果当前链表为空，或者只有一个节点，无需反转，直接返回
           if (head.next == null || head.next.next == null) {
               return;
           }
           // 定义一个辅助的指针（变量）
           HeroNode cur = head.next;
           // 指向当前节点cur的下一个节点，防止链表断裂
           HeroNode next = null;
           HeroNode reverseHead = new HeroNode(0, "", "");
           while (cur != null) {
               // 当前对象的下一个对象
               next = cur.next;
               // 将cur的下一个节点指向新的链表的最前端
               cur.next = reverseHead.next;
               reverseHead.next = cur;
               // 让cur后移
               cur = next;
           }
           // 将reverseHead 给 head
           head.next = reverseHead.next;
       }
   ```

4. 从尾到头打印单链表【百度】

   ![从尾到头打印单链表](img/从尾到头打印单链表.png)
   
   ```java
   
       /**
        * 从尾到头打印单链表【百度】
        * 利用栈的特点先入后出来实现
        * @param head
        */
       public static void reversetPrint(HeroNode head) {
           if (head.next == null) {
               return;
           }
           HeroNode temp = head.next;
           Stack<HeroNode> heroNodes = new Stack<>();
           while(temp != null) {
               heroNodes.push(temp);
               temp = temp.next;
           }
   
           while (heroNodes.size() > 0) {
               System.out.println(heroNodes.pop());
           }
    }
   ```
   

## 4.4 双向链表应用实例

### 4.4.1 双向链表的操作分析和实现

使用带head头的双向链表实现-水浒英雄排行榜

- 管理单向链表的缺点分析：

  - 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找

  - 单向链表不能自我删除，需要靠辅助接点，而双向链表，则可以自我删除

  - 思路图

    ![双向链表删除说明](img/双向链表删除说明.png)

  - 说明

    - 遍历方法和单链表一样，只是可以向前，也可以向后查找

    - 添加(默认添加到双向链表的最后这个节点)

      - 先找到双向链表的最后节点
      - temp.next = newHeroNode
      - newHeroNode.pre=temp;

    - 修改和原来单向链表一致

    - 删除

      - 因为是双向链表，因此，我们可以实现自我删除某个节点
      - 直接找到要删除的这个节点，比如temp
      - temp.pre.next = temp.next
      - temp.next.pre = temp.pre

    - 代码实现

      ```java
      package linklist;
      
      public class DoubleLinkedListDemo {
          public static void main(String[] args) {
              System.out.println("双向链表的测试");
              HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
              HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
              HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
              HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");
              DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
              doubleLinkedList.add(hero1);
              doubleLinkedList.add(hero2);
              doubleLinkedList.add(hero3);
              doubleLinkedList.add(hero4);
              doubleLinkedList.list();
              System.out.println("------");
              doubleLinkedList.update(new HeroNode2(4,"公孙胜","入云龙"));
              doubleLinkedList.list();
              System.out.println("------");
              doubleLinkedList.del(3);
              doubleLinkedList.list();
          }
      }
      
      class DoubleLinkedList {
          private HeroNode2 heroNode2 = new HeroNode2(0, "", "");
      
          public HeroNode2 getHeroNode2() {
              return heroNode2;
          }
      
          void del(int no) {
              if (heroNode2 == null) return;
              HeroNode2 temp = heroNode2.next;
              boolean flag = false;
              while (temp.next != null) {
                  if (temp.no == no) {
                      flag = true;
                      break;
                  }
                  temp = temp.next;
              }
              if (flag) {
                  // 将temp 上一个的元素下一个指向改为temp的下一个，
                  temp.pre.next = temp.next;
                  // 避免temp为最后一个时空指针异常
                  if (temp.next != null)
                      temp.next.pre = temp.pre;
              } else {
                  System.out.println("无法删除");
              }
          }
      
          /**
           * 更新
           *
           * @param newHeroNode
           */
          void update(HeroNode2 newHeroNode) {
              if (newHeroNode == null) {
                  System.out.println("链表为空");
                  return;
              }
              HeroNode2 temp = heroNode2.next;
              boolean flag = false;
              while (temp != null) {
                  if (temp.no == newHeroNode.no) {
                      temp.name = newHeroNode.name;
                      temp.nickName = newHeroNode.nickName;
                      flag = true;
                      break;
                  }
                  temp = temp.next;
              }
              if (!flag) {
                  System.out.println("没有找到");
              }
          }
      
          public void add(HeroNode2 heroNode) {
              // 因为head节点不能动，因此我们需要一个辅助遍历temp
              HeroNode2 temp = heroNode2;
              while (temp.next != null) {
                  temp = temp.next;
              }
              temp.next = heroNode;
              heroNode.pre = temp;
          }
      
          /**
           * 遍历
           */
          void list() {
              // 判断链表是否为空
              if (heroNode2.next == null) {
                  System.out.println("链表为空");
                  return;
              }
              // 因为头节点不能动，因此我们需要一个辅助变量来遍历
              HeroNode2 temp = heroNode2.next;
              while (temp != null) {
      
                  // 输出节点信息
                  System.out.println(temp);
                  temp = temp.next;
              }
          }
      }
      
      class HeroNode2 {
          public int no;
          public String name;
          public String nickName;
          public HeroNode2 next; // 指向下一个节点
          public HeroNode2 pre; // 指向前一个节点
      
          public HeroNode2(int no, String name, String nickName) {
              this.no = no;
              this.name = name;
              this.nickName = nickName;
          }
      
          @Override
          public String toString() {
              return "HeroNode2{" +
                      "no=" + no +
                      ", name='" + name + '\'' +
                      ", nickName='" + nickName + '\'' +
                      '}';
          }
      }
      ```

### 4.4.2 作业和提示

双向链表的第二种添加方式，按照编号顺序添加(按照单链表得到顺序添加，稍作修改即可)

